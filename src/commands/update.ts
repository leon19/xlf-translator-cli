import Command, {flags} from '@oclif/command'
import Bluebird from 'bluebird'
import chalk from 'chalk'
import inquirer from 'inquirer'
import ora from 'ora'
import path from 'path'

import glob from '../lib/glob'
import isBaseMessageFile from '../lib/is-base-message-file'
import localeFromFile from '../lib/locale-from-file'
import makeLanguage from '../lib/make-language'
import parseXmlFile from '../lib/parse-xml-file'
import saveXmlFile from '../lib/save-xml-file'

export default class Update extends Command {
  static description = [
    'Update the translation `*.xlf` files generated by angular.',
    'It is expected to find a `messages.xlf` file and translations files following the format `messages.[locale].xlf`'
  ].join('\n')

  static flags = {
    location: flags.string({
      char: 'l',
      description: 'Folder where translation files `*.xlf` are located (a recursive search is executed)',
      required: true
    })
  }

  private spinner = ora()

  async run() {
    const translations = await this.getTranslations()
    const baseFile = await this.getBaseFile(translations)

    const translatableFiles = await glob(path.join(path.dirname(baseFile), '**/*.*.xlf'))

    const {selectedFiles} = await inquirer.prompt<{ selectedFiles: string[] }>({
      message: 'select files to translate',
      choices: translatableFiles.map(file => ({name: ' ' + file, value: file, checked: true})),
      type: 'checkbox',
      name: 'selectedFiles'
    })

    const baseMessages = await parseXmlFile(baseFile)
    const options = {concurrency: 10}

    this.spinner.start('reading translations...')

    await Bluebird.resolve(selectedFiles)
      .map(file => {
        return Bluebird.props({
          file,
          locale: localeFromFile(file),
          xml: parseXmlFile(file)
        })
      }, options)
      .tap(() => this.spinner.stop())
      .mapSeries(({file, locale, xml}) => {
        return Bluebird.props({
          file,
          xml: makeLanguage({
            locale,
            translation: xml,
            base: baseMessages
          })
        })
      })
      .tap(() => this.spinner.start('writing translations...'))
      .map(({file, xml}) => saveXmlFile({file, xml}), options)
      .catch(({message}: Error) => this.error(chalk.red(`translations could not be updated: ${message}`)))

    this.spinner.succeed('translations updated')
  }

  protected async finally(error: Error | undefined): Promise<any> {
    this.spinner.stop()

    return super.finally(error)
  }

  private async getBaseFile(translations: string[]): Promise<string> {
    const baseFiles = translations.filter(isBaseMessageFile)

    if (baseFiles.length === 0) {
      this.error(chalk.red(`messages.xlf file not found in ${this.getLocation()}`))
    }

    if (baseFiles.length > 1) {
      this.spinner.warn(`${baseFiles.length} messages.xlf files found`)
      const {baseFile} = await inquirer.prompt<{ baseFile: string }>({
        message: 'select messages.xlf file',
        choices: baseFiles,
        type: 'list',
        name: 'baseFile'
      })

      return baseFile
    }

    return baseFiles[0]
  }

  private async getTranslations(): Promise<string[]> {
    this.spinner.start('searching messages.xlf file...')
    const location = this.getLocation()

    const pattern = path.join(location, './**/*.xlf')

    const files = await glob(pattern)

    this.spinner.stop()

    return files
  }

  private getLocation() {
    return path.resolve(process.cwd(), this.parse(Update).flags.location)
  }
}
